// SPDX-License-Identifier: GPL-3.0-or-later
//! Makefile generation for building the PROM image from generated assembly files.

use anyhow::Result;
use std::io::Write;
use std::path::Path;

use super::util::create_output_file;
use crate::hardware::memmap::ROM_ALIGN;
use crate::section::Section;

/// Generate a Makefile that builds the PROM image from the generated assembly files.
#[rustfmt::skip]
pub fn generate_makefile(output_path: &Path, sections: &[Section], has_trailing: bool) -> Result<()> {
    let mut file = create_output_file(output_path, "Makefile")?;

    // Collect section names
    let section_names: Vec<&str> = sections.iter().map(|s| s.shdr.name.as_str()).collect();
    let code_sections: Vec<&Section> = sections
        .iter()
        .filter(|s| s.shdr.is_code())
        .collect();
    let data_sections: Vec<&str> = sections
        .iter()
        .filter(|s| !s.shdr.is_code())
        .map(|s| s.shdr.name.as_str())
        .collect();

    writeln!(file, "# Auto-generated Makefile for building PROM image")?;
    writeln!(file, "# Generated by ip32prom-decompiler")?;
    writeln!(file)?;

    // Tools (defaults provided for standalone use; parent Makefile exports overrides)
    writeln!(file, "# Tools (defaults for standalone use; parent Makefile exports overrides)")?;
    writeln!(file, "MIPS_CHOST_CANDIDATES := mips64-unknown-linux-gnu- mips64-linux-gnu- mips-linux-gnu-")?;
    writeln!(file, "detect_mips_chost = $(firstword $(foreach prefix,$(MIPS_CHOST_CANDIDATES),$(if $(shell command -v $(prefix)as 2>/dev/null),$(prefix))))")?;
    writeln!(file, "MIPS_CHOST ?= $(or $(detect_mips_chost),mips-linux-gnu-)")?;
    writeln!(file, "CHECKSUM ?= cargo run --manifest-path ../Cargo.toml --release --bin ip32prom-checksum --")?;
    writeln!(file)?;

    // Flags
    writeln!(file, "# Flags")?;
    writeln!(file, "MIPS_FLAGS = -mabi=64 -march=mips3")?;
    writeln!(file, "LDFLAGS = -EB -melf64btsmip -static")?;
    writeln!(file)?;

    // Constants
    writeln!(file, "# SHDR alignment")?;
    writeln!(file, "ROM_ALIGN = {}", ROM_ALIGN)?;
    writeln!(file)?;

    // Output file
    writeln!(file, "# Output")?;
    writeln!(file, "PROM = prom.bin")?;
    writeln!(file)?;

    // Section lists
    writeln!(file, "# Sections")?;
    write!(file, "CHECKSUM_SECTIONS =")?;
    for name in &section_names {
        write!(file, " {}", name)?;
    }
    writeln!(file)?;
    if has_trailing {
        writeln!(file, "ALL_SECTIONS = $(CHECKSUM_SECTIONS) trailing")?;
    } else {
        writeln!(file, "ALL_SECTIONS = $(CHECKSUM_SECTIONS)")?;
    }
    writeln!(file)?;

    // Derived file lists
    writeln!(file, "# Derived file lists")?;
    writeln!(file, "BIN_FILES = $(addsuffix .bin,$(ALL_SECTIONS))")?;
    writeln!(file, "CHECKSUM_BIN_FILES = $(addsuffix .bin,$(CHECKSUM_SECTIONS))")?;
    writeln!(file)?;

    // Disable built-in rules
    writeln!(file, "# Disable built-in suffix rules")?;
    writeln!(file, ".SUFFIXES:")?;
    writeln!(file)?;

    // Delete targets on error
    writeln!(file, "# Delete partial files on error")?;
    writeln!(file, ".DELETE_ON_ERROR:")?;
    writeln!(file)?;

    // Default target
    writeln!(file, "# Default target")?;
    writeln!(file, "all: $(PROM)")?;
    writeln!(file)?;

    // Helper function for padding
    writeln!(file, "# Helper to pad a file to ROM_ALIGN boundary")?;
    writeln!(file, "define pad_to_align")?;
    writeln!(file, "\t@size=$$(stat -c%s $(1)); \\")?;
    writeln!(file, "\taligned_size=$$(( (size + $(ROM_ALIGN) - 1) / $(ROM_ALIGN) * $(ROM_ALIGN) )); \\")?;
    writeln!(file, "\tcp $(1) $(2); \\")?;
    writeln!(file, "\ttruncate -s $$aligned_size $(2)")?;
    writeln!(file, "endef")?;
    writeln!(file)?;

    // PROM concatenation rule
    writeln!(file, "# Concatenate all section binaries into final PROM image")?;
    writeln!(file, "$(PROM): $(BIN_FILES)")?;
    writeln!(file, "\tcat $^ > $@")?;
    writeln!(file)?;

    // Pattern rules for preprocessing and assembly
    writeln!(file, "# Preprocess .S files to .s files")?;
    writeln!(file, "%.s: %.S definitions.h macros.inc")?;
    writeln!(file, "\t$(CPP) $< -o $@")?;
    writeln!(file)?;

    writeln!(file, "# Assemble .s files to .o files")?;
    writeln!(file, "%.o: %.s")?;
    writeln!(file, "\t$(MIPS_CHOST)as $(MIPS_FLAGS) $< -o $@")?;
    writeln!(file)?;

    // Rules for each code section
    for section in &code_sections {
        let name = &section.shdr.name;
        writeln!(file, "# {} section (code)", name)?;
        writeln!(file, "{}.elf: {}.o {}.lds", name, name, name)?;
        writeln!(file, "\t$(MIPS_CHOST)ld $(MIPS_FLAGS) $(LDFLAGS) -T {}.lds $< -o $@", name)?;
        writeln!(file)?;

        // Generate objcopy command with all required ELF sections
        let elf_sections = section.elf_sections_for_objcopy();
        let section_flags: String = elf_sections
            .iter()
            .map(|s| format!("-j {}", s))
            .collect::<Vec<_>>()
            .join(" ");

        writeln!(file, "{}.bin: {}.elf", name, name)?;
        writeln!(file, "\t$(MIPS_CHOST)objcopy {} -O binary $< $@.tmp", section_flags)?;
        writeln!(file, "\t$(call pad_to_align,$@.tmp,$@)")?;
        writeln!(file, "\t@rm -f $@.tmp")?;
        writeln!(file, "\t$(CHECKSUM) --set $@")?;
        writeln!(file)?;
    }

    // Rules for data sections
    for name in &data_sections {
        writeln!(file, "# {} section (data)", name)?;
        writeln!(file, "{}.bin: {}.o", name, name)?;
        writeln!(file, "\t$(MIPS_CHOST)objcopy -j .text -O binary $< $@.tmp")?;
        writeln!(file, "\t$(call pad_to_align,$@.tmp,$@)")?;
        writeln!(file, "\t@rm -f $@.tmp")?;
        writeln!(file, "\t$(CHECKSUM) --set $@")?;
        writeln!(file)?;
    }

    // Trailing data rule (no checksum, no padding)
    if has_trailing {
        writeln!(file, "# Trailing data (no SHDR, no checksum)")?;
        writeln!(file, "trailing.bin: trailing.o")?;
        writeln!(file, "\t$(MIPS_CHOST)objcopy -j .text -O binary $< $@")?;
        writeln!(file)?;
    }

    // Verify checksums target
    writeln!(file, "# Verify checksums in all section binaries")?;
    writeln!(file, "verify-checksums: $(CHECKSUM_BIN_FILES)")?;
    writeln!(file, "\t@echo \"Verifying section checksums...\"")?;
    writeln!(file, "\t@for f in $(CHECKSUM_BIN_FILES); do \\")?;
    writeln!(file, "\t\t$(CHECKSUM) --verify \"$$f\" || exit 1; \\")?;
    writeln!(file, "\t\techo \"\"; \\")?;
    writeln!(file, "\tdone")?;
    writeln!(file, "\t@echo \"All section checksums verified!\"")?;
    writeln!(file)?;

    // Clean target
    writeln!(file, "# Clean generated files")?;
    writeln!(file, "clean:")?;
    writeln!(file, "\trm -f *.o *.s *.elf *.bin *.tmp")?;
    writeln!(file)?;

    // Phony targets
    writeln!(file, ".PHONY: all clean verify-checksums")?;

    Ok(())
}
