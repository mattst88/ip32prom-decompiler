[
{ "0x81000050": "Zero BSS" },
{ "0x81000090": "Initialize stack pointer" },
{ "0x81000830": "Call 0xbfc00100 with a0=7, a1=0" },
{ "0x81000e3c": "1.0f / 0x7fffffff" },
{ "0x81000ecc": "1.0f / 0x7fffffff" },
{ "0x8100ca88": "CRIME_DE_SCRMASK1 (base register has +8 offset)" },
{ "0x8100caac": "CRIME_DE_SCRMASK2 (base register has +8 offset)" },
{ "0x8100cac8": "CRIME_DE_SCRMASK3 (base register has +8 offset)" },
{ "0x8100cae4": "CRIME_DE_SCRMASK4 (base register has +8 offset)" },
{ "0x8101776c": "Load saved $sp from exception context" },
{ "0x81017774": "If valid, use interrupted context's stack" },
{ "0x8101777c": "Otherwise use dedicated exception stack" },
{ "0xbfc00118": "CRIME_MC_STATUS_CTRL; disable ECC" },
{ "0xbfc003b8": "Branch to warm_start if (ST0_NMI|ST0_SR) set" },
{ "0xbfc003d4": "Branch to warm_start if (CRIME_CONTROL_TRITON_SYSADC|CRIME_CONTROL_CRIME_SYSADC) set" },
{ "0xbfc003dc": "Initialize GPRs to 0" },
{ "0xbfc00458": "Save status register" },
{ "0xbfc00468": "Enable floating-point unit" },
{ "0xbfc00478": "Initialize FPRs to 0.0" },
{ "0xbfc00500": "Initialize FPU control register" },
{ "0xbfc0050c": "... Twice?" },
{ "0xbfc00518": "Restore status register" },
{ "0xbfc00524": "*0xbf3a3707 = (t9 >>  0) & 0xff" },
{ "0xbfc0052c": "*0xbf3a3807 = (t9 >>  8) & 0xff" },
{ "0xbfc00534": "*0xbf3a3907 = (t9 >> 16) & 0xff" },
{ "0xbfc0053c": "*0xbf3a3a07   (t9 >> 24) & 0xff" },
{ "0xbfc00544": "*0xbf3a3b07   (t9 >> 32) & 0xff" },
{ "0xbfc0054c": "*0xbf3a3d07   (t9 >> 48) & 0xff" },
{ "0xbfc00560": "*0xbf3a3e07   (t9 >> 56) & 0xff" },
{ "0xbfc00578": "Turn on Green and Red LEDs" },
{ "0xbfc00594": "Branch to 0x5f0 if in bootstrap" },
{ "0xbfc005a0": "Set bootstrap mode" },
{ "0xbfc005a8": "Branch if a0 is 2, 3, 4, 5, 7, 6" },
{ "0xbfc005c0": "Branch if a0 is 1" },
{ "0xbfc005d0": "Branch if a0 is 0" },
{ "0xbfc00650": "Set KSEG0 to cacheable, noncoherent" },
{ "0xbfc00694": "*(long *)0xbf318000 = 0x400" },
{ "0xbfc0069c": "*(long *)0xbf318020 = 0x400" },
{ "0xbfc006a4": "*(long *)0xbf31c000 = 0x400" },
{ "0xbfc006ac": "*(long *)0xbf31c020 = 0x400" },
{ "0xbfc006b8": "Reset ISA controller" },
{ "0xbfc006c8": "Delay... count down from 256" },
{ "0xbfc006d0": "ISA_RING_BASE_AND_RESET; take out of reset state" },
{ "0xbfc006e4": "$sp = 0x80001000" },
{ "0xbfc00784": "ISA_MISC_CONTROL" },
{ "0xbfc00790": "Delay... count down from 8<<48" },
{ "0xbfc00a98": "Pointer to 0xbfc01e70 containing struct { start=0xbfc00000, end=0xbfc80000, alignment=0x100, length=0x00080000, 0xbfc00c48, nop1, isa_reset }" },
{ "0xbfc00a9c": "Pointer to 0xbfc01de0 containing \"post1\"" },
{ "0xbfc00aa0": "Call find_valid_section_by_name(flash_info, \"post1\", 0)" },
{ "0xbfc00ab0": "Pointer to 0xbfc01de8 containing \"firmware\"" },
{ "0xbfc00ab4": "Pointer to 0xbfc01e70 containing struct { start=0xbfc00000, end=0xbfc80000, alignment=0x100, length=0x00080000, 0xbfc00c48, nop1, isa_reset }" },
{ "0xbfc00abc": "Call find_section_by_name(flash_info, \"firmware\", 0)" },
{ "0xbfc00ac0": "Save address of post1 section" },
{ "0xbfc00acc": "ISA_MISC_CONTROL" },
{ "0xbfc00ad0": "ISA_MISC_CONTROL + 0x04" },
{ "0xbfc00ad8": "$v1 = address of post1 section" },
{ "0xbfc00ae4": "ISA_MISC_CONTROL" },
{ "0xbfc00aec": "$a1 = address of firmware section" },
{ "0xbfc00b00": "Call post1($a0=$a0, $a1=address of firmware section, $a2=$a1)" },
{ "0xbfc00b14": "ISA_MISC_CONTROL" },
{ "0xbfc00b18": "ISA_MISC_CONTROL + 0x04" },
{ "0xbfc00c48": "void ...(out $a0, in $a1)" },
{ "0xbfc00c88": "ISA_MISC_CONTROL + 0x04" },
{ "0xbfc00c8c": "ISA_MISC_CONTROL" },
{ "0xbfc00c94": "ISA_MISC_CONTROL + 0x04" },
{ "0xbfc00c9c": "ISA_MISC_CONTROL" },
{ "0xbfc00ca4": "ISA_MISC_CONTROL" },
{ "0xbfc00ca8": "ISA_MISC_CONTROL + 0x04" },
{ "0xbfc00cbc": "ISA_MISC_CONTROL + 0x04" },
{ "0xbfc00cc0": "ISA_MISC_CONTROL" },
{ "0xbfc01298": "Load address from table (0xbf390407)" },
{ "0xbfc014fc": "Load address from table (0xbf390407)" },
{ "0xbfc01508": "$v0 = *(char *)0xbf390407" },
{ "0xbfc01514": "*(char *)0xbf390407 |= 1;" },
{ "0xbfc01520": "*(char *)0xbf390407 &= ~1;" },
{ "0xbfc015f0": "Calls exception_uncached_exception with $a0=2" },
{ "0xbfc0161c": "Calls exception_uncached_exception with $a0=3" },
{ "0xbfc01648": "Calls exception_uncached_exception with $a0=4" },
{ "0xbfc01674": "Calls exception_uncached_exception with $a0=5" },
{ "0xbfc016a0": "Calls exception_uncached_exception with $a0=6" },
{ "0xbfc017ec": "Load section alignment requirement" },
{ "0xbfc017f0": "Load section alignment requirement" },
{ "0xbfc01824": "$s0 is within the system ROM?" },
{ "0xbfc01844": "$s0 is within the system ROM?" },
{ "0xbfc01874": "$t6 = Load the length of the section" },
{ "0xbfc0187c": "$v1 = address of end of SHDR" },
{ "0xbfc01880": "$a1 = address of end of section" },
{ "0xbfc01890": "$v0 = address of data to be checksummed" },
{ "0xbfc01898": "$a2 = checksum" },
{ "0xbfc018c4": "$t9 = word[0]" },
{ "0xbfc018c8": "$t0 = word[1]" },
{ "0xbfc018cc": "$t1 = word[2]" },
{ "0xbfc018d0": "checksm += word[0]" },
{ "0xbfc018d4": "$t2 = word[3]" },
{ "0xbfc018d8": "checksum += word[1]" },
{ "0xbfc018dc": "word += 16" },
{ "0xbfc018e0": "checksum += word[2]" },
{ "0xbfc018e4": "branch while not at end" },
{ "0xbfc018e8": "checksum += word[3]" },
{ "0xbfc018f0": "return checksum == 0" },
{ "0xbfc0191c": "if (memcmp(&shdr->magic, \"SHDR\", sizeof(shdr->magic)) != 0) return 0;" },
{ "0xbfc01930": "if ((shdr->section_len & 0x3) != 0) return 0;" },
{ "0xbfc01940": "$a1 & $v1 are different and const, so this is a dead branch" },
{ "0xbfc01950": "This branch is always taken" },
{ "0xbfc019c0": "Jump to (KSEG1 | tlb_init)" },
{ "0xbfc01d98": "unused?" },
{ "0xbfc04474": "Save address of firmware section" },
{ "0xbfc044bc": "0xbfc06fd0, start of loadable subsection" },
{ "0xbfc044c0": "0xbfc09120, end of loadable subsection" },
{ "0xbfc044c4": "0xa0004000, address of destination" },
{ "0xbfc04510": "ISA_MISC_CONTROL" },
{ "0xbfc04514": "$t0 = address of firmware section" },
{ "0xbfc04528": "$s0 = address of firmware section" },
{ "0xbfc04588": "$s2 = address of subsection header" },
{ "0xbfc0461c": "Load section checksum" },
{ "0xbfc04624": "Branch if checksum fails" },
{ "0xbfc04644": "Set KSEG0 to cacheable, noncoherent" },
{ "0xbfc05320": "ISA_MISC_CONTROL" },
{ "0xbfc05328": "ISA_MISC_CONTROL" },
{ "0xbfc0533c": "ISA_MISC_CONTROL" },
{ "0xbfc05e78": "ISA_MISC_CONTROL" },
{ "0xbfc05e88": "ISA_MISC_CONTROL" },
{ "0xbfc05e94": "ISA_MISC_CONTROL" },
{ "0xbfc05ea0": "ISA_MISC_CONTROL" },
{ "0xbfc06240": "Pointer to 0xbfc09130, containing 0xb5000000" },
{ "0xbfc063a0": "Pointer to 0xbfc09130, containing 0xb5000000" },
{ "0xbfc063bc": "Pointer to 0xbfc09130, containing 0xb5000000" },
{ "0xbfc0640c": "Pointer to 0xbfc09130, containing 0xb5000000" },
{ "0xbfc06544": "Pointer to 0xbfc09130, containing 0xb5000000" },
{ "0xbfc06604": "Pointer to 0xbfc09130, containing 0xb5000000" },
{ "0xbfc06750": "Jump to (KSEG1 | tlb_init)" },
{}
]
